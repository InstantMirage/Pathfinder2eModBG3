Version 1
SubGoalCombiner SGC_AND
INITSECTION
DB_InterruptStepAwaySpells("Target_SuddenShift", 2.0);
KBSECTION
//REGION Spells that cause an immediate step away from a triggering attack
IF
UsingSpellOnTarget((GUIDSTRING)_Caster, (GUIDSTRING)_Target, (STRING)_Spell, _, _, (INTEGER)_ActionID)
AND
DB_InterruptStepAwaySpells(_Spell, (REAL)_Distance)
THEN
DB_InterruptStepAwayActive(_ActionID, _Distance, _Caster, _Target);
ApplyStatus(_Caster, "INTERRUPT_FREE_MOVEMENT", 1.0);

// This might look like a lot, but it really just calculates the unit vector
// from target to caster, and adds that, multiplied by distance, to the caster's
// position.
IF
CastedSpell((GUIDSTRING)_Caster, _, _, _, (INTEGER)_ActionID)
AND
DB_InterruptStepAwayActive(_ActionID, (REAL)_Distance, _Caster, (GUIDSTRING)_Target)
AND
GetPosition(_Caster, (REAL)_XC, (REAL)_YC, (REAL)_ZC)
AND
GetPosition(_Target, (REAL)_XT, (REAL)_YT, (REAL)_ZT)
AND
QRY_VectorABByDistance(_XC, _YC, _ZC, _XT, _YT, _ZT, -2.0)
AND
DB_QRYRTN_VectorABByDistance((REAL)_XCN, (REAL)_YCN, (REAL)_ZCN)
THEN
CharacterMoveToPosition((CHARACTER)_Caster, _XCN, _YCN, _ZCN, "Run", "ClearStrideConditionOffTurn");

// Would otherwise leave characters starting their turn with
// stride, which is very bad.
IF
EntityEvent((GUIDSTRING)_Caster, "ClearStrideConditionOffTurn")
AND
DB_InterruptStepAwayActive((INTEGER)_ActionID, (REAL)_Distance, _Caster, (GUIDSTRING)_Target)
THEN
NOT DB_InterruptStepAwayActive(_ActionID, _Distance, _Caster, _Target);
RemoveStatus(_Caster, "STRIDE");
RemoveStatus(_Caster, "INTERRUPT_FREE_MOVEMENT");
PROC_SteerToCause(_Caster, _Target);

PROC
PROC_SteerToCause((GUIDSTRING)_Caster, (GUIDSTRING)_Target)
THEN
SteerTo((CHARACTER)_Caster, (CHARACTER)_Target, 0);
//END_REGION

//REGION Shove
// When a character shoves something, this status is applied
// to the entity. Keep track of the current shove caster/target
// pair in a DB. Clear it out first.
IF
StatusApplied((GUIDSTRING)_Target, "SHOVE_REACT", (GUIDSTRING)_Caster, _)
AND
DB_CurrentShoveAction((GUIDSTRING)_OldT, (GUIDSTRING)_OldC)
THEN
NOT DB_CurrentShoveAction(_OldT, _OldC);

IF
StatusApplied((GUIDSTRING)_Target, "SHOVE_REACT", (GUIDSTRING)_Caster, _)
THEN
DB_CurrentShoveAction(_Target, _Caster);

// When a shove is finished, the shoved character loses this
// status, and we have to apply another status that triggers
// the interrupt, but we need Osiris to maintain cause data.
IF
StatusRemoved((GUIDSTRING)_Target, "SHOVE_REACT", _, _)
AND
DB_CurrentShoveAction(_Target, (GUIDSTRING)_Caster)
THEN
ApplyStatus(_Target, "SHOVE_TRIGGER", 0.0, 0, _Caster);

// When the shove follow interrupt awaits user input, we
// find a safe place to stand near the target, and ping it.
IF
ReactionInterruptActionNeeded((GUIDSTRING)_Caster)
AND
DB_CurrentShoveAction((GUIDSTRING)_Target, _Caster)
AND
GetPosition(_Caster, (REAL)_XC, (REAL)_YC, (REAL)_ZC)
AND
GetPosition(_Target, (REAL)_XT, (REAL)_YT, (REAL)_ZT)
AND
QRY_VectorABByRatio(_XC, _YC, _ZC, _XT, _YT, _ZT, 0.8)
AND
DB_QRYRTN_VectorABByRatio((REAL)_X, (REAL)_Y, (REAL)_Z)
AND
FindValidPosition(_X, _Y, _Z, 1.0, _Caster, 0, (REAL)_SafeX, (REAL)_SafeY, (REAL)_SafeZ)
THEN
RequestPing(_SafeX, _SafeY, _SafeZ, NULL_00000000-0000-0000-0000-000000000000, NULL_00000000-0000-0000-0000-000000000000);

// When the interupt is actually used, we calculate the same
// position again, but actually move to it.
IF
ReactionInterruptUsed((GUIDSTRING)_Caster, "ShoveReaction", _)
AND
DB_CurrentShoveAction((GUIDSTRING)_Target, _Caster)
AND
GetPosition(_Caster, (REAL)_XC, (REAL)_YC, (REAL)_ZC)
AND
GetPosition(_Target, (REAL)_XT, (REAL)_YT, (REAL)_ZT)
AND
QRY_VectorABByRatio(_XC, _YC, _ZC, _XT, _YT, _ZT, 0.8)
AND
DB_QRYRTN_VectorABByRatio((REAL)_X, (REAL)_Y, (REAL)_Z)
AND
FindValidPosition(_X, _Y, _Z, 1.0, _Caster, 0, (REAL)_SafeX, (REAL)_SafeY, (REAL)_SafeZ)
THEN
ApplyStatus(_Caster, "INTERRUPT_FREE_MOVEMENT", -1.0, 1, _Caster);
PROC_ShoveReactionMove(_Caster, _SafeX, _SafeY, _SafeZ);

PROC
PROC_ShoveReactionMove((GUIDSTRING)_Caster, (REAL)_SafeX, (REAL)_SafeY, (REAL)_SafeZ)
THEN
CharacterMoveToPosition((CHARACTER)_Caster, _SafeX, _SafeY, _SafeZ, "Run", "ShoveReactionMove");

IF
EntityEvent((GUIDSTRING)_Caster, "ShoveReactionMove")
THEN
ApplyStatus(_Caster, "DEBUG_RESET_MOVE", -1.0, 1, _Caster);
RemoveStatus(_Caster, "INTERRUPT_FREE_MOVEMENT");
//END_REGION
EXITSECTION

ENDEXITSECTION
