Version 1
SubGoalCombiner SGC_AND
INITSECTION
DB_ConcealedTags((TAG)CONCEALED_9b389131-5c4f-4aff-afcf-4a4d2723e385);
DB_ConcealedTags((TAG)CONCEALED_NO_HIDE_6379ad1e-499f-4dde-9b43-07f1b2c27ec8);
KBSECTION
//REGION Flat Checks
// When any character starts casting a spell (target selected)
// give them a flat check value as a status. We will compare
// this value when we fire interrupts, and thus all the
// flat check conditions will automatically use the same roll
// and not need any stacking logic.

// Make flat check roll for caster
IF
UsingSpell((GUIDSTRING)_Caster, _, _, _, (INTEGER)_ID)
AND
Random(19, (INTEGER)_RollMinusOne)
AND
IntegerSum(_RollMinusOne, 1, (INTEGER)_Roll)
AND
IntegerProduct(_Roll, 6, _Duration)
AND
IntegerToReal(_Duration, (REAL)_DurationReal)
THEN
ApplyStatus(_Caster, "FLAT_CHECK_ROLL", _DurationReal, 1, _Caster);

//END_REGION

//REGION On change of obscurity, apply statuses
IF
ObscuredStateChanged((GUIDSTRING)_Character, (STRING)_State)
AND
_State == "HeavilyObscured"
THEN
ApplyStatus(_Character, "IN_DARKNESS", -1.0);
RemoveStatus(_Character, "IN_DIM_LIGHT");

IF
ObscuredStateChanged((GUIDSTRING)_Character, (STRING)_State)
AND
_State == "LightlyObscured"
THEN
ApplyStatus(_Character, "IN_DIM_LIGHT", -1.0);
RemoveStatus(_Character, "IN_DARKNESS");

IF
ObscuredStateChanged((GUIDSTRING)_Character, (STRING)_State)
AND
_State == "Clear"
THEN
RemoveStatus(_Character, "IN_DARKNESS");
RemoveStatus(_Character, "IN_DIM_LIGHT");
//END_REGION

//REGION Concealment stacking
// Lots of possible sources of concealment exist with various durations.
// Using tags to track whether a character should be concealed allows
// for cleaner handling of cases where one source of concealment
// disappears whilst another is still active.
IF
TagSet((GUIDSTRING)_Character, (TAG)_Tag)
AND
DB_ConcealedTags(_Tag)
THEN
ApplyStatus(_Character, "CONCEALED", -1.0);

// If a tag is removed, we have to check if any other concealment tag
// is still present before removing the condition. We do this by
// clearing out the value 1 from a DB, then running a check for the
// possible concealment tags, adding the value 1 back into the DB
// on success. We then check if the value 1 is present in the DB to
// determine if we should remove the status.
IF
TagCleared((GUIDSTRING)_Character, (TAG)_Tag)
AND
DB_ConcealedTags(_Tag)
THEN
NOT DB_ConcealedTagSuccess(1);
PROC_TestConcealedAll(_Character);
PROC_ResultConcealedTag(_Character);

PROC
PROC_TestConcealedAll((GUIDSTRING)_Character)
AND
DB_ConcealedTags((TAG)_AllTags)
THEN
PROC_TestConcealedTag(_AllTags, _Character);

PROC
PROC_TestConcealedTag((TAG)_Tag, (GUIDSTRING)_Character)
AND
IsTagged(_Character, _Tag, 1)
THEN
DB_ConcealedTagSuccess(1);

PROC
PROC_ResultConcealedTag((GUIDSTRING)_Character)
AND
NOT DB_ConcealedTagSuccess(1)
THEN
RemoveStatus(_Character, "CONCEALED");

IF
TagSet((GUIDSTRING)_Character, DAZZLED_5453990a-f917-4b7e-a324-b1de320de33e)
THEN
ApplyStatus(_Character, "DAZZLED", -1.0);

IF
TagCleared((GUIDSTRING)_Character, DAZZLED_5453990a-f917-4b7e-a324-b1de320de33e)
THEN
RemoveStatus(_Character, "DAZZLED");

IF
TagSet((GUIDSTRING)_Character, INVISIBLE_457ab381-7903-463c-9507-8b7db47ac016)
THEN
ApplyStatus(_Character, "INVISIBLE", -1.0);

IF
TagCleared((GUIDSTRING)_Character, INVISIBLE_457ab381-7903-463c-9507-8b7db47ac016)
THEN
RemoveStatus(_Character, "INVISIBLE");
//END_REGION

//REGION Dazzled for 1 hour is implemented as a removal on short rest
IF
ShortRested((CHARACTER)_Character)
AND
HasActiveStatus((GUIDSTRING)_Character, "DAZZLED_APPLY", 1)
THEN
RemoveStatus(_Character, "DAZZLED_APPLY");
//END_REGION

//REGION Base Game Sneaking
// Whenever a character enters combat while sneaking, remove the base
// game sneaking effect and immediately trigger a hide check.
IF
EnteredCombat((GUIDSTRING)_Character, _)
AND
HasActiveStatus(_Character, "SNEAKING", 1)
THEN
RemoveStatus(_Character, "SNEAKING");
UseSpell(_Character, "Shout_Hide", _Character);
//END_REGION

//REGION Hide Checks
// If the player uses Shout_Hide we begin the hidden check process
IF
CastedSpell((GUIDSTRING)_Cause, "Shout_Hide", _, _, _)
AND
TimerExists("HideCheckTimer", 0)
THEN
TimerLaunch("HideCheckTimer", 30);

// Marked characters are saved for after the timer expires.
IF
StatusApplied((GUIDSTRING)_Character, "HIDDEN_FROM_TECHNICAL", (GUIDSTRING)_Cause, _)
THEN
DB_HideCheckSchedule(_Character, _Cause);

// Allows Osiris to detect which characters are immune to the
// cause's concealment.
IF
StatusApplied((GUIDSTRING)_Character, "HIDE_CHECK_CONCEALED_BLOCK", (GUIDSTRING)_Cause, _)
THEN
DB_HideCheckConcealedBlock(_Character, _Cause);

// Allows Osiris to detect which causes are not affected by the
// character's dazzled.
IF
StatusApplied((GUIDSTRING)_Character, "HIDE_CHECK_DAZZLED_BLOCK", (GUIDSTRING)_Cause, _)
THEN
DB_HideCheckDazzledBlock(_Character, _Cause);

// Check every marked character to see if their passive perception beats
// the hidden roll value.
IF
TimerFinished("HideCheckTimer")
AND
DB_HideCheckSchedule((GUIDSTRING)_Character, (GUIDSTRING)_Cause)
AND
CalculatePassiveSkill(_Cause, "Stealth", (INTEGER)_PassiveSkill)
AND
IntegerSubtract(_PassiveSkill, 10, (INTEGER)_ModifierSkill)
AND
GetStatusTurns(_Cause, "HIDE_CHECK_RESULT", (INTEGER)_Roll)
AND
IntegerSum(_Roll, _ModifierSkill, (INTEGER)_TotalRoll)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
THEN
NOT DB_HideCheckSchedule(_Character, _Cause);
NOT DB_CheckConditionsForHideResult(_Character, _Cause);
PROC_CheckConditionsForHide(_Character, _Cause, _TotalRoll, _PassivePerception);
NOT DB_HideCheckConcealedBlock(_Character, _Cause);
NOT DB_HideCheckDazzledBlock(_Character, _Cause);
PROC_ApplyHiddenFromConditional(_Character, _Cause, _Roll);

PROC
PROC_ApplyHiddenFromConditional((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll)
AND
DB_CheckConditionsForHideResult(_Character, _Cause)
AND
_Roll > 1
THEN
ApplyStatus(_Character, "HIDDEN_FROM", -1.0, 0, _Cause);
NOT DB_CheckConditionsForHideResult(_Character, _Cause);

// A number of circumstances need to be covered by PROC_CheckConditionsForHide

// Character can't see Cause, presume standard cover, and
// ignore concealment. We currently don't have any bonuses
// that would need to stack cleverly with this.
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasLineOfSight(_Character, _Cause, 0)
AND
IntegerSum(_Roll, 2, (INTEGER)_TotalRoll)
AND
_TotalRoll >= _PassivePerception
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Cause is concealed from Character, by a means that doesn't
// care about darkvision.
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCheckConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_DARKVISION_3b4fb323-8d19-441d-b256-1fa359a9bbcd, 1)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_GREATER_DARKVISION_05fb05f0-84be-46c6-b772-90859a01c95d, 1)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
_Roll >= _PassivePerception
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Cause is concealed from Character, by a means that does care
// about greater darkvision.
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCheckConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_DARKVISION_3b4fb323-8d19-441d-b256-1fa359a9bbcd, 1)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
_Roll >= _PassivePerception
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Cause is concealed from Character, by a means that does care
// about all darkvision.
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCheckConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
HasPassive(_Character, "Darkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
_Roll >= _PassivePerception
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// If the cause is in full darkness, or otherwise persistently hidden,
// they automatically succeed against non-darkvision characters.
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
IsTagged(_Cause, (TAG)DARKNESS_badb91be-7a47-4898-beed-d0e3a7083783, 1)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
HasPassive(_Character, "Darkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Character is Dazzled
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatus(_Character, "DAZZLED", 1)
AND
NOT DB_HideCheckDazzledBlock(_Character, _Cause)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
_Roll >= _PassivePerception
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Character is Blinded
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatusWithGroup(_Character, "SG_Blinded", 1)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

// Cause is Invisible
PROC
PROC_CheckConditionsForHide((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll, (INTEGER)_PassivePerception)
AND
HasActiveStatusWithGroup(_Cause, "SG_Invisible", 1)
AND
HasActiveStatus(_Character, "SEE_INVISIBILITY", 0)
THEN
DB_CheckConditionsForHideResult(_Character, _Cause);

//END_REGION

//REGION Sneak Checks
// When the player gains the SNEAK_CHECK condition, start a timer to trigger
// checks on all entities the aura marked.
IF
StatusApplied((GUIDSTRING)_Cause, "SNEAK_CHECK", _, _)
AND
TimerExists("SneakCheckTimer", 0)
THEN
TimerLaunch("SneakCheckTimer", 30);

// Marked characters are saved for after the timer expires.
IF
StatusApplied((GUIDSTRING)_Character, "SNEAK_TECHNICAL", (GUIDSTRING)_Cause, _)
THEN
DB_SneakCheckSchedule(_Character, _Cause);

// Check every marked character to see if their passive perception beats
// the hidden roll value.
IF
TimerFinished("SneakCheckTimer")
AND
DB_SneakCheckSchedule((GUIDSTRING)_Character, (GUIDSTRING)_Cause)
AND
CalculatePassiveSkill(_Cause, "Stealth", (INTEGER)_PassiveSkill)
AND
IntegerSubtract(_PassiveSkill, 10, (INTEGER)_ModifierSkill)
AND
GetStatusTurns(_Cause, "HIDE_CHECK_RESULT", (INTEGER)_Roll)
AND
IntegerSum(_Roll, _ModifierSkill, (INTEGER)_TotalRoll)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
THEN
NOT DB_SneakCheckSchedule(_Character, _Cause);
NOT DB_CheckConditionsForHideResult(_Character, _Cause);
PROC_CheckConditionsForHide(_Character, _Cause, _TotalRoll, _PassivePerception);
ApplyStatus(_Cause, "UNDETECTED_CLEANUP", 0.0, 0, _Cause);
PROC_ApplyUndetectedFromConditional(_Character, _Cause, _Roll);
PROC_CritFailRemoveHidden(_Character, _Cause, _TotalRoll, _PassivePerception, _Roll);

PROC
PROC_ApplyUndetectedFromConditional((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_Roll)
AND
DB_CheckConditionsForHideResult(_Character, _Cause)
AND
_Roll > 1
THEN
ApplyStatus(_Character, "UNDETECTED_FROM_HELPER_A", 0.0, 0, _Cause);
DB_UndetectedHelperSchedule(_Character, _Cause);
NOT DB_CheckConditionsForHideResult(_Character, _Cause);

// Critical failure without cover buff. To selectively remove hidden, we
// apply a status on the hider caused by the target we want to remove it
// from.
PROC
PROC_CritFailRemoveHidden((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_TotalRoll, (INTEGER)_PassivePerception, (INTEGER)_Roll)
AND
HasLineOfSight(_Character, _Cause, 1)
AND
IntegerMin(_Roll, 2, (INTEGER)_RollOneOrTwo)
AND
IntegerSubtract(_RollOneOrTwo, 1, (INTEGER)_RollZeroOrOne)
AND
IntegerProduct(_RollZeroOrOne, 10, (INTEGER)_CritModifier)
AND
IntegerSubtract(_PassivePerception, 11, (INTEGER)_CritBase)
AND
IntegerSum(_CritBase, _CritModifier, (INTEGER)_CritThreshold)
AND
_TotalRoll < _CritThreshold
THEN
PROC_ApplyHiddenFrom(_Character, _Cause);
ApplyStatus(_Cause, "UNDETECTED_FROM_REMOVE", 0.0, 0, _Character);

// Critical failure with cover buff
PROC
PROC_CritFailRemoveHidden((GUIDSTRING)_Character, (GUIDSTRING)_Cause, (INTEGER)_TotalRoll, (INTEGER)_PassivePerception, (INTEGER)_Roll)
AND
HasLineOfSight(_Character, _Cause, 0)
AND
IntegerMin(_Roll, 2, (INTEGER)_RollOneOrTwo)
AND
IntegerSubtract(_RollOneOrTwo, 1, (INTEGER)_RollZeroOrOne)
AND
IntegerProduct(_RollZeroOrOne, 10, (INTEGER)_CritModifier)
AND
IntegerSubtract(_PassivePerception, 11, (INTEGER)_CritBase)
AND
IntegerSum(_CritBase, _CritModifier, (INTEGER)_CritThreshold)
AND
_TotalRoll < _CritThreshold
THEN
PROC_ApplyHiddenFrom(_Character, _Cause);
ApplyStatus(_Cause, "UNDETECTED_FROM_REMOVE", 0.0, 0, _Character);

// These two procs handle the invisibility interaction, as invisible creatures
// (usually) can't be spotted.
PROC
PROC_ApplyHiddenFrom((GUIDSTRING)_Character, (GUIDSTRING)_Cause)
AND
HasActiveStatusWithGroup(_Cause, "SG_Invisible", 0)
THEN
ApplyStatus(_Cause, "HIDDEN_FROM_REMOVE", 0.0, 0, _Character);

PROC
PROC_ApplyHiddenFrom((GUIDSTRING)_Character, (GUIDSTRING)_Cause)
AND
HasActiveStatusWithGroup(_Cause, "SG_Invisible", 1)
AND
HasActiveStatus(_Character, "SEE_INVISIBILITY", 1)
THEN
ApplyStatus(_Cause, "HIDDEN_FROM_REMOVE", 0.0, 0, _Character);

// I'm not entirely sure why, but directly applying the status breaks with
// non-hostile NPCs, resulting in enormous stacks of UNDETECTED that can't
// be removed. Applying it through a proxy like this fixes that. Sadly
// Osiris can't detect the cause of an existing status, so A and B work
// in tandem to make that condition check.
IF
StatusApplied((GUIDSTRING)_Character, "UNDETECTED_FROM_HELPER_B", _, _)
AND
DB_UndetectedHelperSchedule(_Character, (GUIDSTRING)_Cause)
THEN
ApplyStatus(_Character, "UNDETECTED_FROM", -1.0, 0, _Cause);
NOT DB_UndetectedHelperSchedule(_Character, _Cause);
//END_REGION

//REGION Hide Rechecking
// When a character sees another character, we check to see if that has
// any impact upon the hidden condition. At this stage, we can't check if
// the HIDDEN_FROM condition came from the entity the character saw, so we
// must do that in a status.
IF
Saw((CHARACTER)_Character, (CHARACTER)_Cause, _)
AND
HasLineOfSight((GUIDSTRING)_Character, (GUIDSTRING)_Cause, 1)
AND
HasActiveStatus(_Cause, "HIDDEN", 1)
AND
HasActiveStatus(_Character, "HIDDEN_FROM", 1)
THEN
ApplyStatus(_Character, "HIDE_RECHECK", 0.0, 0, _Cause);
//END_REGION

//REGION Free Hide
IF
StatusApplied((GUIDSTRING)_Character, "HIDE_FREE", (GUIDSTRING)_Cause, _)
AND
TimerExists("HideCheckTimer", 0)
THEN
TimerLaunch("HideCheckTimer", 30);
//END_REGION

//REGION NPC Hide DC Calculation
// Originally we did these calcs in Khonsu, but the CPU load on NPC
// turns was untenably large. Instead, we calculate the hide DC once
// on the start of an NPC's turn, and just assume that that will be
// close enough throughout that turn. All the complexity here is just
// to ensure that the calculations for multiple entities with
// concurrent turns don't step on each other.
IF
TurnStarted((GUIDSTRING)_Character)
AND
IsPlayer((CHARACTER)_Character, 0)
THEN
ApplyStatus(_Character, "HIDE_NPC_CALC", 0.0);

IF
StatusApplied((GUIDSTRING)_Character, "HIDE_NPC_CALC", _, _)
AND
GUIDToString(_Character, (STRING)_GUIDString)
AND
Concatenate("HideCalculationGetDC", _GUIDString, (STRING)_HideDCString)
AND
Concatenate("HideCalculationFinal", _GUIDString, (STRING)_HideFinalString)
THEN
DB_HideCalculationNPC(_Character, 0, _HideDCString, _HideFinalString);
IteratePlayerCharacters(_HideDCString, _HideFinalString);

// Allows Osiris to detect which characters are immune to the
// cause's concealment.
IF
StatusApplied((GUIDSTRING)_Character, "HIDE_CHECK_NPC_CONCEALED_BLOCK", (GUIDSTRING)_Cause, _)
THEN
DB_HideCalculationNPCConcealedBlock(_Character, _Cause);

// Allows Osiris to detect which causes are not affected by the
// character's dazzled.
IF
StatusApplied((GUIDSTRING)_Character, "HIDE_CHECK_NPC_DAZZLED_BLOCK", (GUIDSTRING)_Cause, _)
THEN
DB_HideCalculationNPCDazzledBlock(_Character, _Cause);

// Character can't see Cause, presume standard cover, and
// ignore concealment. We currently don't have any bonuses
// that would need to stack cleverly with this.
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasLineOfSight(_Character, _Cause, 0)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_RawPerception)
AND
IntegerSum(_RawPerception, 2, (INTEGER)_PassivePerception)
AND
_PassivePerception > _Current
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, _PassivePerception, _HideDCString, _HideFinalString);

// Cause is concealed from Character, by a means that doesn't
// care about darkvision.
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCalculationNPCConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_DARKVISION_3b4fb323-8d19-441d-b256-1fa359a9bbcd, 1)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_GREATER_DARKVISION_05fb05f0-84be-46c6-b772-90859a01c95d, 1)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
AND
_PassivePerception > _Current
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, _PassivePerception, _HideDCString, _HideFinalString);

// Cause is concealed from Character, by a means that does care
// about greater darkvision.
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCalculationNPCConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
IsTagged(_Cause, (TAG)CONCEALED_TO_DARKVISION_3b4fb323-8d19-441d-b256-1fa359a9bbcd, 1)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
AND
_PassivePerception > _Current
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, _PassivePerception, _HideDCString, _HideFinalString);

// Cause is concealed from Character, by a means that does care
// about all darkvision.
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatus(_Cause, "CONCEALED", 1)
AND
NOT DB_HideCalculationNPCConcealedBlock(_Character, _Cause)
AND
IsTagged(_Cause, (TAG)CONCEALED_DISABLE_b9f18995-a30d-4dd0-b009-9fa832acb8e1, 0)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
HasPassive(_Character, "Darkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
AND
_PassivePerception > _Current
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, _PassivePerception, _HideDCString, _HideFinalString);

// If the cause is in full darkness, or otherwise persistently hidden,
// they automatically succeed against non-darkvision characters.
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
IsTagged(_Cause, (TAG)DARKNESS_badb91be-7a47-4898-beed-d0e3a7083783, 1)
AND
HasPassive(_Character, "SuperiorDarkvision", 0)
AND
HasPassive(_Character, "Darkvision", 0)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, 1, _HideDCString, _HideFinalString);

// Character is Dazzled
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatus(_Character, "DAZZLED", 1)
AND
NOT DB_HideCalculationNPCDazzledBlock(_Character, _Cause)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
AND
CalculatePassiveSkill(_Character, "Perception", (INTEGER)_PassivePerception)
AND
_PassivePerception > _Current
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, _PassivePerception, _HideDCString, _HideFinalString);

// Character is Blinded
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatusWithGroup(_Character, "SG_Blinded", 1)
AND
IsTagged(_Character, (TAG)BLINDSIGHT_a49c94ac-6903-408e-8b05-86371fd865c0, 0)
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, 1, _HideDCString, _HideFinalString);

// Cause is Invisible
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
HasActiveStatusWithGroup(_Cause, "SG_Invisible", 1)
AND
HasActiveStatus(_Character, "SEE_INVISIBILITY", 0)
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, 1, _HideDCString, _HideFinalString);

// Characters that are allied with the player cannot hide
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
AND
IsAlly((CHARACTER)_Character, (CHARACTER)_Cause, 1)
THEN
NOT DB_HideCalculationNPC((GUIDSTRING)_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, 100, _HideDCString, _HideFinalString);

// Cleanup
IF
EntityEvent((GUIDSTRING)_Character, (STRING)_HideDCString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Cause, (INTEGER)_Current, _HideDCString, (STRING)_HideFinalString)
THEN
NOT DB_HideCalculationNPCConcealedBlock(_Character, _Cause);
NOT DB_HideCalculationNPCDazzledBlock(_Character, _Cause);

// Once every entity is checked, if no valid sources of DC were found, hiding
// is either impossible due to direct sight, or irrelevent. Set DC to 100.
IF
EntityEvent(_, _HideFinalString)
AND
DB_HideCalculationNPC(_Cause, (INTEGER)_Current, (STRING)_HideDCString, (STRING)_HideFinalString)
AND
_Current == 0
THEN
NOT DB_HideCalculationNPC(_Cause, _Current, _HideDCString, _HideFinalString);
DB_HideCalculationNPC(_Cause, 100, _HideDCString, _HideFinalString);

// Set a status to store the DC for the character.
IF
EntityEvent(_, _HideFinalString)
AND
DB_HideCalculationNPC((GUIDSTRING)_Character, (INTEGER)_DC, (STRING)_HideDCString, _HideFinalString)
AND
IntegerProduct(_DC, 6, (INTEGER)_DCMult)
AND
IntegerToReal(_DCMult, (REAL)_DCReal)
THEN
ApplyStatus(_Character, "HIDE_NPC_DC", _DCReal, 1, _Character);
NOT DB_HideCalculationNPC(_Character, _DC, _HideDCString, _HideFinalString);
//END_REGION
EXITSECTION

ENDEXITSECTION
